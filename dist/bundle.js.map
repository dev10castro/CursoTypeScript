{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;AAAa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,uDAAuD;AACvD;AACA;AACA;AACA,0MAA0M,cAAc;AACxN,8BAA8B,sBAAsB;AACpD,0BAA0B,YAAY,sBAAsB,qCAAqC,2CAA2C,MAAM;AAClJ,4BAA4B,MAAM,iBAAiB,YAAY;AAC/D,uBAAuB;AACvB,8BAA8B;AAC9B,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,yBAAyB;AACzB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY,EAAE,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA,eAAe;AACf,eAAe,kEAAkE;AACjF,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,eAAe,KAAK,cAAc;AAC3E,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA,6DAA6D,eAAe,gBAAgB,GAAG,OAAO,GAAG,cAAc,KAAK;AAC5H,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ,EAAE,SAAS;AAC/C;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,2CAA2C,wBAAwB,iBAAiB,iBAAiB,OAAO;AAC5G;AACA,eAAe;AACf,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe,cAAc,EAAE,OAAO;AACxE;AACA,oCAAoC,eAAe,aAAa,KAAK;AACrE,0CAA0C,eAAe,aAAa,KAAK;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,qBAAqB;AACrB;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B,+BAA+B,KAAK,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD,2BAA2B;;AAEnF,gBAAgB,cAAc;AAC9B;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,uCAAuC;AACvC,uCAAuC;AACvC;AACA;AACA;AACA,qFAAqF,KAAK;AAC1F;AACA;AACA;AACA;;;AAGA;AACA,4CAA4C,qBAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oCAAoC,aAAa,OAAO,eAAe,YAAY,IAAI,cAAc,IAAI,mBAAmB,MAAM,oCAAoC,MAAM,OAAO;AACnL,oCAAoC,aAAa,OAAO,eAAe,YAAY,IAAI,cAAc,IAAI,kBAAkB,MAAM,oCAAoC,MAAM,OAAO;AAClL,oCAAoC,aAAa,OAAO,eAAe,YAAY,IAAI,cAAc,IAAI,kBAAkB,MAAM,oCAAoC,MAAM,OAAO;AAClL,oCAAoC,aAAa,OAAO,eAAe,YAAY,IAAI,cAAc,IAAI,kBAAkB,MAAM,oCAAoC,MAAM,OAAO;AAClL;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,gDAAgD;AAChD,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA,wBAAwB;AACxB,2BAA2B;AAC3B;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA,uBAAuB,QAAQ,EAAE,SAAS;AAC1C;AACA;AACA,uBAAuB,QAAQ,EAAE,SAAS,kBAAkB,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;UEzcA;UACA;UACA;UACA;UACA","sources":["webpack://cursotypescript/./src/index.ts","webpack://cursotypescript/webpack/before-startup","webpack://cursotypescript/webpack/startup","webpack://cursotypescript/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nconsole.log(\"Hola mundo2\");\n/**\n * TIPOS DE DATOS\n *\n * string\n * number - enteros y decimales\n * boolean - true / false\n * null\n * undefined\n *\n */\nvar nombre = \"David\"; //VARIABLE GLOBAL\nlet apellido = \"Castro\"; //Variable Local\nconst PI = 3.1416; //Variable Constante (siempre mayusculas)\n/**\n * Concatenar texto\n */\nconsole.log(nombre + \" \" + apellido);\nconsole.log(nombre, apellido);\nconsole.log(`Hola ${nombre}`);\nlet a, b, c; //Podemos iniciar varias variables en la misma linea\na = \"texto\";\nb = \"texto2\";\nc = 2;\n//Arrays de datos\nlet alumnos1 = [\"Juan\", \"Jose\", \"Alex\"];\nlet alumnos2 = [\"Fran\"];\nlet valores = [\"Jose\", 5, 4];\nlet alumnos = [...alumnos1, ...alumnos2, \"Pepe\"];\nconsole.log(alumnos);\n//Como definimos objetos\nlet misDatos = {\n    nombre: \"David\",\n    apellido: \"Castro\",\n    edad: 18\n};\nlet configuracion = {\n    versionTs: \"Es6\",\n    versionCodigo: \"1.0\"\n};\nconfiguracion.versionCodigo;\nlet propiedad1 = configuracion.versionCodigo;\nlet propiedad2 = configuracion.versionTs;\nconsole.log(`${propiedad1} ${propiedad2}`);\n//enumerados\nvar EstadoTarea;\n(function (EstadoTarea) {\n    EstadoTarea[\"Terminado\"] = \"T\";\n    EstadoTarea[\"Pendiente\"] = \"P\";\n    EstadoTarea[\"EnProceso\"] = \"E\";\n})(EstadoTarea || (EstadoTarea = {}));\n;\nlet estado = EstadoTarea.Pendiente;\nconsole.log(estado);\nlet tarea1 = { nombre: \"tarea 1\", prioridad: 2, estado: EstadoTarea.EnProceso };\nlet tarea0 = { nombre: \"tarea 0\", prioridad: 2, estado: EstadoTarea.EnProceso }; //sirve pero no es buena pratica\nlet empleado1 = { nombre: \"David\", edad: 38, sueldo: 1400 };\nconsole.log(empleado1);\nlet empleado2;\nempleado2 = { nombre: \"David\", edad: 38, sueldo: 1400, codigo: \"ad34dd\" };\n// Estructuras de control y repeticion\n//Operador ternario\n// condicion ? verdadero : falso\nconsole.log(tarea1.estado == \"T\" ? `La tarea ${tarea1.nombre} se ha terminado` : `Terminado`);\n// IF-ELSE\nif (tarea1.estado == \"T\") {\n    //codigo 1\n}\nelse if (tarea1.estado == \"E\") {\n    //codigo 2\n}\nelse {\n    //resto de casos\n}\n//Switch\nswitch (tarea1.estado) {\n    case \"T\":\n        console.log(\"Terminado\");\n        break;\n    case \"P\":\n        console.log(\"Pendiente\");\n        break;\n    case \"E\":\n        console.log(\"en proceso\");\n        break;\n    default:\n    //resto de codigo\n}\ntry {\n    let numero1 = 1;\n    console.log(numero1.toString());\n}\ncatch (error) {\n    console.log(\"Se ha producido un error al pasar el numero a string\", error);\n}\n/*\nEstrucuturas de repeticion - bucles\n*/\nlet tarea2 = { estado: EstadoTarea.Terminado, nombre: \"Tarea 2\", prioridad: 0 };\nlet listadoTareas = [tarea0, tarea1, tarea2];\n// foreach\nlistadoTareas.forEach((elemento, indice, arreglo) => {\n    console.log(indice, elemento, arreglo[indice].estado);\n});\n// WHILE\nwhile (tarea1.estado != EstadoTarea.Terminado) {\n    console.log(\"Tarea no completada\");\n    tarea1.estado = EstadoTarea.Terminado;\n}\ndo {\n    console.log(`El estado de la tarea ${tarea1.nombre} es ${tarea1.estado}`);\n} while (tarea1.estado != EstadoTarea.Terminado);\n/**\n * Funciones: nos permitirá crear bloque de códigos reutilizables.\n * funtion name (nameParam: type):{}\n */\n// Funciónes clásicas y documentación del código\n/**\n * Muestra un saludo por consola a una persona\n * @param nombre string nombre del usuario\n */\nfunction saludar(nombre) {\n    console.log(`Hola ${nombre}, qué tal estas?`);\n}\nsaludar(\"David Castro\");\n//Funciones con parámeros por defecto\nfunction saludarDefault(nombre = \"David\") {\n    console.log(`Hola ${nombre}, qué tal estas?`);\n}\nsaludarDefault();\nsaludarDefault(\"Juan\");\n//Funciones con parámeros opcionales\nfunction saludarOpcional(nombre) {\n    let nombreParam = nombre;\n    if (nombreParam == undefined) {\n        nombreParam = \"Nombre Defecto\";\n    }\n    console.log(`Hola ${nombreParam}, qué tal estas?`);\n}\nsaludarOpcional();\n// Clase 2/10/2024\nfor (let x = 0; x <= 10; x++) {\n    console.log(x);\n}\n// (valor1,valor2,valor3) => {}\nlistadoTareas.forEach((elemento, indice, listadoTareas) => { console.log(`${elemento.nombre}-${indice}-${listadoTareas}`); });\nfor (let i = 0; i < listadoTareas.length; i++) {\n    let elemento = listadoTareas[i];\n    console.log(elemento);\n}\n// DO{} WHILE()\n//FUNCIONES BASICAS\n/**\n * dado el parametro nombre muestra por pantalla\n * @param nombre nombre a saludar\n */\nfunction saludar2(direccion, nombre = \"david\", apellido) {\n    if (apellido != undefined) {\n        console.log(`Hola ${nombre} ${apellido}`);\n    }\n    else {\n        console.log(`Hola ${nombre}`);\n    }\n    console.log(typeof (direccion));\n}\nsaludar2(\"moron\", \"Garcia\");\n//funciones anonimas\nlet fanonima = function () { console.log(\"hola mundo\"); };\nfanonima();\nlet fitera = function (elemento, indice) { console.log(`la tarea ${elemento.nombre} esta en numero ${indice}`); };\nlistadoTareas.forEach(fitera);\nlet tarea3 = { estado: EstadoTarea.Terminado, nombre: \"Tarea 3\", prioridad: 0 };\nlet tarea4 = { estado: EstadoTarea.Terminado, nombre: \"Tarea 4\", prioridad: 0 };\n// funciones con multiples parametros\nfunction muestraTareas(...nombres) {\n    nombres.forEach(fitera);\n}\nmuestraTareas(tarea0, tarea2, tarea1, tarea3, tarea4);\nlet listadoTareas2 = [...listadoTareas, tarea3, tarea4];\nmuestraTareas(...listadoTareas2);\n// funciones arrow\nlet farrow = (tarea, indice) => { console.log(`${tarea.nombre} ${indice}`); };\nlistadoTareas2.forEach(farrow);\nlistadoTareas2.forEach((tarea) => { console.log(`${tarea.nombre}`); });\nlistadoTareas2.forEach(function (tarea) { console.log(`${tarea.nombre}`); });\nfarrow(tarea0, 1);\nlet fsuma = function suma(a, b) {\n    return a + b;\n};\nlet fresta = function resta(a, b) {\n    return a - b;\n};\nfunction opera(x, y, funcion) {\n    return funcion(x, y);\n}\nopera(2, 3, fsuma); //suma 2+3\nopera(2, 3, fresta); //resta 2-3\n//Funciones asincronas\nfunction asincrona() {\n    return __awaiter(this, void 0, void 0, function* () {\n        let suma = 0;\n        for (let i = 1; i <= 10; i++) {\n            suma += i;\n        }\n        return suma;\n    });\n}\nasincrona().then((data) => { console.log(`el resultado es ${data}`); });\nconsole.log(\"fin de la funcion asincrona\");\n/*\nasync function getDataUniversity(): Promise<Universidad[]> {\n    const data = await fetch(\"https://universities.hipolabs.com/search?country=Spain\");\n    let respuesta : Promise<Universidad[]> = await data.json() as Promise<Universidad[]>;\n    return respuesta;\n}\n\n//\n\ntype Universidad = {\n    domains: string[],\n    alpha_two_code: string,\n    name: string,\n}\n\ngetDataUniversity().then((data:Universidad[])=>{\n    //console.log(data.forEach((elemento:Universidad)=>{console.log(elemento.name)}))\n\n    for(let i=0;i<data.length;i++){\n        console.log(data[i].name);\n    }\n});\n*/\n//FUNCION GENERADORA\nfunction* generadora() {\n    for (let tarea in listadoTareas) {\n        {\n            yield listadoTareas[tarea];\n        }\n    }\n}\nlet funcionGeneradora = generadora();\nconsole.log(funcionGeneradora.next()); // tarea 1\nconsole.log(funcionGeneradora.next()); // tarea 2\nconsole.log(funcionGeneradora.next()); // tarea 3\n/*\n//FUNCIONES ASINCRONAS\nasync function getUniversitiesAsync(pais: string): Promise<Universidad[]> {\n    const response = await fetch(`https://universities.hipolabs.com/search?country=${pais}`);\n    const data: Universidad[] = await response.json() as Universidad[];\n    return data;\n}\n    \n\n\n// Llamamos a la función asincrona y mostramos el JSON de las universidades existentes en Spain\ngetUniversitiesAsync(\"Spain\").then((data)=>{console.log(data[1])});\n*/\n// Como curiosidad, podéis observar que esta línea se ejecuta antes aún estando después de la llamada a la API. \n// Esto ocurre porque la función getDataFromAPI es una función asíncrona y muestra los resultados en el momento que termina su ejecución.\nconsole.log(\"Linea posterior a funcion async\");\n/**\n * FUNCIONES GENERADORAS:\n * Una función generadora es una función que se puede pausar y reanudar, y por lo tanto, nos puede devolver múltiples valores.\n * Para poder declarar una función generadora es necesario añadir el * después de la palabra reservada function.\n * Observa que en lugar de llamar a return para devolver un valor, utilizamos yield.\n * Fuente:https://lenguajejs.com/javascript/funciones/generadores/\n */\n// Ejemplo 1: Función que itera elementos de un array y los devuelve\nfunction* fGenTareas() {\n    let tareas = [...listadoTareas];\n    for (let i in tareas) {\n        yield tareas[i];\n    }\n    // No es posible usar la función foreach porque al ser una función callback no se puede usar con yield.\n}\n// Preparamos nuestra función generadora\nconst genTareas = fGenTareas();\nconsole.log(genTareas.next()); // Accedemos al primer valor del array\n// Podemos obtener todos los valores de nuestra función generadora usando el operador spread\n// const getAllTareas = [...fGenTareas()];\n// console.log(getAllTareas);\nfunction* fgeneradora2() {\n    yield \"hola\";\n    yield \"mundo\";\n    yield \"adios\";\n}\nlet fgen2 = fgeneradora2();\nconsole.log(fgen2.next()); //hola\nconsole.log(fgen2.next()); //mundo\nconsole.log(fgen2.next()); //adios\nfunction generatorGetBreaches() {\n    return __asyncGenerator(this, arguments, function* generatorGetBreaches_1() {\n        let respuesta = yield __await(fetch(\"https://haveibeenpwned.com/api/v2/breaches\"));\n        // Convertimos la respuesta de la petición GET en un archivo JSON\n        let datos = yield __await(respuesta.json());\n        for (let i in datos) {\n            yield yield __await(datos[i]);\n        }\n    });\n}\nlet valoresUniversidades = generatorGetBreaches();\nvaloresUniversidades.next().then(({ value, done }) => { console.log(`${value.Name} - ${value.Domain} - ${value.Description} \\n`); console.log(`Is the last element? ${done} \\n`); });\nvaloresUniversidades.next().then(({ value, done }) => { console.log(`${value.Name} - ${value.Domain} - ${value.Description}\\n`); console.log(`Is the last element? ${done} \\n`); });\nvaloresUniversidades.next().then(({ value, done }) => { console.log(`${value.Name} - ${value.Domain} - ${value.Description}\\n`); console.log(`Is the last element? ${done} \\n`); });\nvaloresUniversidades.next().then(({ value, done }) => { console.log(`${value.Name} - ${value.Domain} - ${value.Description}\\n`); console.log(`Is the last element? ${done} \\n`); });\n// Implementación de la función\nfunction funcionSobrecarga(param) {\n    // hacer cosas\n    return \"\";\n}\nfuncionSobrecarga(12); // esto no da error\nfuncionSobrecarga(\"12\"); // esto no da error\n// Implementación de la función\nfunction funcionSobrecargaDiffParam(a, b) {\n    if (typeof a === \"string\" && typeof b === \"string\") {\n        return a + b;\n    }\n    else if (typeof a === \"number\" && typeof b === \"number\") {\n        return a + b;\n    }\n    throw new Error(\"Tipos de parámetros no coinciden\");\n}\nconsole.log(funcionSobrecargaDiffParam(\"Hola, \", \"mundo\")); // \"Hola, mundo\"\nconsole.log(funcionSobrecargaDiffParam(5, 10)); // 15\n//console.log(funcionSobrecargaDiffParam(\"Hola\", 10)); //ERROR\nfuncionSobrecarga(13);\n// Implementación de la función\nfunction mostrarMensaje(mensaje, veces) {\n    if (veces === undefined) {\n        console.log(mensaje);\n    }\n    else {\n        for (let i = 0; i < veces; i++) {\n            console.log(mensaje);\n        }\n    }\n}\nmostrarMensaje(\"Hola\"); // \"Hola\"\nmostrarMensaje(\"Hola\", 3); // \"Hola\" \"Hola\" \"Hola\"\nfunction saludos(nombre, apellido, edad) {\n    if (apellido == undefined && edad == undefined) {\n        return `Hola ${nombre}`;\n    }\n    else if (edad == undefined) {\n        return `Hola ${nombre} ${apellido}`;\n    }\n    else {\n        return `Hola ${nombre} ${apellido}, tu edad es de ${edad} años.`;\n    }\n}\nconsole.log(saludos(\"David\"));\nconsole.log(saludos(\"David\", \"Castro\"));\nconsole.log(saludos(\"David\", \"Castro\", \"38\"));\n/*EJERCICIO 1\nCrea una función en tu proyecto que reciba como parámetro un string llamado \"type\" que tendrá como valor por defecto \"SessionStorage\", un string\nllamado \"key\", un array de objetos Tarea llamado \"data\" . El funcionamiento de dicha función debe ser el siguiente: dependiendo de si el valor del\nparámetro \"type\" es \"session\" o \"local\" se almacenará la información del array empleando el objeto \"SessionStorage\" o \"LocalStorage\". La información\ndel parámetro data se almacenará usando la key pasada como parámetro\n*/\nfunction userSession(type = \"SessionStorage\", key, data) {\n    if (type == \"session\") {\n        sessionStorage.setItem(key, JSON.stringify(data));\n        console.log(\"Datos almacenados correctamente en SessionStorage\");\n    }\n    else if (type == \"local\") {\n        localStorage.setItem(key, JSON.stringify(data));\n        console.log(\"Datos almacenados correctamente en LocalStorage\");\n    }\n    else {\n        console.log(\"Tipo de almacenamiento no válido\");\n    }\n}\n/* EJERCICIO 3\nEjecuta la función anterior usando pasándole como parámetro el valor de type \"session\", un array\nde Tareas, y como clave \"datos\". Además, deberás ejecutar de nuevo la  función pasándole como parámetro\nel valor de type \"local\", un array de Tareas, y como clave \"datos\".\n*/\nlet listaTareas = [tarea0, tarea1, tarea2, tarea3, tarea4];\n//mostramos la info\nuserSession(\"session\", \"datos\", listaTareas);\nuserSession(\"local\", \"datos\", listaTareas);\n/* EJERCICIO 4\nCrea una función en tu proyecto que permita recuperar la información almacenada en SessionStorage y LocalStorage.\nDicha función debe recibir dos parámetros: type que será un string y tendrá como valor por defecto \"session\", y un string\nllamado \"key\". El funcionamiento de la función debe ser el siguiente: dependiendo el valor de type, si es \"sessión\" o\n\"local\", se recuperará la información empleando el objeto \"SessionStorage\" o \"LocalStorage\" y la key pasada como parámetro.\n*/\nfunction recoverInfo(type = \"session\", key) {\n    if (type == \"session\") {\n        let info = sessionStorage.getItem(key);\n        console.log(info);\n    }\n    else if (type == \"local\") {\n        let info = localStorage.getItem(key);\n        console.log(info);\n    }\n    else {\n        console.log(\"Type no valido\");\n    }\n}\n/*EJERCICIO 5\nRecupera la información almacenada en el navegador y muestrala por consola.\n*/\nrecoverInfo(\"session\", \"datos\");\nrecoverInfo(\"local\", \"datos\");\n/*EJERCICIO 6\nCrea una función del mismo estilo que las anteriores que permita borrar la información\nalmacenada en SessiónStorage y LocalStorage. Solo debe recibir como parámetro un string\nllamado \"type\" y un string llamado \"key\". Ejecuta dicha función tantas veces como sea\nnecesaria para borrar toda la información almacenada.\n*/\nfunction deleteInfo(type = \"session\", key) {\n    if (type == \"session\") {\n        for (let i = 0; i < sessionStorage.length; i++) {\n            sessionStorage.removeItem(key);\n        }\n        console.log(\"Datos eliminados correctamente de SessionStorage\");\n    }\n    else if (type == \"local\") {\n        for (let i = 0; i < localStorage.length; i++) {\n            localStorage.removeItem(key);\n            console.log(\"Datos eliminados correctamente de LocalStorage\");\n        }\n    }\n    else {\n        console.log(\"Type no valido\");\n    }\n}\n//deleteInfo(\"session\",\"datos\");\n//deleteInfo(\"local\",\"datos\");\n//Crea una cookie llamada nombre con tu nombre que expire a los 7 días y sea accesible desde el path /\n//Crea una cookie llamada apellidos con tu apellido que expire a los 2 días\n//Crea una cookie llamada email con un email que expire a los 4 días.\n//Recupera todas las cookies anteriores.\n//Borra todas las cookies anteriores\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[\"./src/index.ts\"]();\n",""],"names":[],"sourceRoot":""}